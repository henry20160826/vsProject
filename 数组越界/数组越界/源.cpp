#include<iostream>
#include<stdlib.h>
using namespace std;
int d = 101;
void str()
{
	//关于字符串越界的思考
	char b = 'b';
	char a[] = "hi";
	char *p;
	char c = 'c';
	cout << "a[-15]:" << a[-15] << "\n";//真的能越界，还不报错
	cout << "a[15]:" << a[15] << "\n";//真的能越界，还不报错
	//有的编译器会检查是否越界
	p = a;

	int len = strlen(a) - 1;

	int i;
	for (i = len; a[i] != c; i--)
	{

	}
	cout << "查找c的i：" << i << "\n";//真的越界输出
	cout << "a[0]的地址：" << (void *)p << "\n";
	p++;
	cout << "a[1]的地址：" << (void *)p << "\n";
	p = &c;
	cout << "c的地址：" << (void *)p << "\n";
	//某次运行的结果
	//i的值为-21
	//a[0]的地址 0018F9DC
	//a[1]的地址 0018F9DD
	//c   的地址 0018F9C7
	//现有的变量a，a先入栈，之后有的变量c，从栈的角度看，a应该在c的下面，a更靠近栈底
	//可以看出栈底的地址要比栈顶的地址大，说明栈向着地址小的方向发展
	//从a的各个元素的情况可以看出，编号小的地址小，更靠近栈顶，a中元素地址的发展方向和栈的发展方向相反
	//i--的过程是指向再向a中地址小的方向移动，所以之后能够访问到c本身的地址，c的地址减去a[0]的地址结果为-21

	for (i = len; a[i] != b; i--)
	{

	}
	p = &b;
	cout << "b的地址：" << (void *)p << "\n";//真的越界输出
	cout << "寻找b：" << i << "\n";//真的越界输出
	//b先入栈，b的地址要比a的地址大。但还是找到了b。这么大的地址空间碰巧有个b并不稀奇。
	//查找c时每次运行输出的i是固定的，但是查找b时每次输出的i是不确定的。
	//这说明了查找c时，找到了c本身
	//查找b时，查到的是一个随机的巧合
	//反向查找b能找到b本身的地址
}

void numArray()
{
	//关于数组越界的思考，因为int占4个字节，所以运行结果和字符串的情况有些不同
	int b = 100;
	int a[] = { 2,3,5,6,3,8 };
	int *p;
	int c = 99;
	cout << "a[-15]:" << a[-15] << "\n";//真的能越界，还不报错
	cout << "a[15]:" << a[15] << "\n";//真的能越界，还不报错
	//有的编译器会检查是否越界
	p = a;

	int len = sizeof(a) / sizeof(int) - 1;

	int i;
	for (i = len; a[i] != c; i--)
	{

	}
	cout << "查找c的i：" << i << "\n";//真的越界输出
	cout << "a[0]的地址：" << (void *)p << "\n";
	p++;
	cout << "a[1]的地址：" << (void *)p << "\n";
	p = &c;
	cout << "c的地址：" << (void *)p << "\n";
	//某次运行的结果
	//i的值为-6
	//a[0]的地址 0018F9F0
	//a[1]的地址 0018F9F4
	//c   的地址 0018F9D6
	//现有的变量a，a先入栈，之后有的变量c，从栈的角度看，a应该在c的下面，a更靠近栈底
	//可以看出栈底的地址要比栈顶的地址大，说明栈向着地址小的方向发展
	//从a的各个元素的情况可以看出，编号小的地址小，更靠近栈顶，a中元素地址的发展方向和栈的发展方向相反，a向着地址大的方向发展
	//i--的过程是指向再向a中地址小的方向移动，所以之后能够访问到c本身的地址，c的地址减去a[0]的地址结果为-24(十进制)
	//-24除以int所占的内存空间4，结果为-6

	//for (i = len; a[i] != b; i--)
	//{

	//}
	//p = &b;
	//cout << "b的地址：" << (void *)p << "\n";//真的越界输出
	//cout << "寻找b：" << i << "\n";
	//上面这段会报错，毕竟4个字节的巧合要比1个字节的巧合难得多，跑到别的程序的地址空间去了，会崩溃


	//for (i = 0; a[i] != b; i++)
	//{

	//}
	//p = &b;
	//cout << "b的地址：" << (void *)p << "\n";//真的越界输出
	//cout << "寻找b：" << i << "\n";
	//反向查找b能找到b本身的地址

	//查找全局变量
	//for (i = len; a[i] != d; i--)
	//{

	//}
	//p = &d;
	//cout << "d的地址：" << (void *)p << "\n";//真的越界输出
	//cout << "寻找d的i：" << i << "\n";
	//上面越界崩溃

	//for (i = 0; a[i] != d; i++)
	//{

	//}
	//p = &d;
	//cout << "d的地址：" << (void *)p << "\n";//真的越界输出
	//cout << "寻找d的i：" << i << "\n";
	//上面读取访问权限冲突
	//两边都找不到全局变量d,可以猜想，栈区和静态存储去在内存上是不连续的
}

void main()
{
	//str();
	numArray();
	while (1);
}